// Usage:
//     package yourcollection
//
//     import "github.com/genkami/dogs/types/iterator"
//
//     // go:generate go run .../../cmd/gen-collection -pkg yourcollection -name YourCollection -out zz_generated.collection.go
//     type YourCollection[T] struct { ... }
//     func FromIterator[T any](it iterator.Iterator[T]) YourCollection[T] { ... }
//     func (xs YourCollection[T]) Iter() iterator.Iterator[T] { ... }

package main

import (
	"flag"
	"fmt"
	"os"
	"text/template"
)

func main() {
	var (
		pkgName string
		typeName string
		output string
	)

	flag.StringVar(&pkgName, "pkg", "", "the name of the package")
	flag.StringVar(&typeName, "name", "", "the name of the type")
	flag.StringVar(&output, "out", "", "path to output")
	flag.Parse()

	if pkgName == "" {
		fmt.Fprintf(os.Stderr, "gen-collection: missing -pkg")
		os.Exit(1)
	}
	if typeName == "" {
		fmt.Fprintf(os.Stderr, "gen-collection: missing -type-name")
		os.Exit(1)
	}
	if output == "" {
		fmt.Fprintf(os.Stderr, "gen-collection: missing -out")
		os.Exit(1)
	}

	w, err := os.Create(output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "gen-collection: failed to open %s: %s", output, err.Error())
		os.Exit(1)
	}
	defer w.Close()

	tmpl := template.Must(template.New("collection.go.tmpl").Parse(rawTmpl))
	tmpl.Execute(w, map[string]string{
		"PkgName": pkgName,
		"TypeName": typeName,
	})
}

const rawTmpl = `// Code generated by gen-collection; DO NOT EDIT.

package {{ .PkgName }}

import (
	"github.com/genkami/dogs/classes/algebra"
	"github.com/genkami/dogs/classes/cmp"
	"github.com/genkami/dogs/types/iterator"
	"github.com/genkami/dogs/types/pair"
)

// Find returns a first element in xs that satisfies the given predicate fn.
// It returns false as a second return value if no elements are found.
func Find[T any](xs {{ .TypeName }}[T], fn func(T) bool) (T, bool) {
	return iterator.Find[T](xs.Iter(), fn)
}

// FindIndex returns a first index of an element in xs that satisfies the given predicate fn.
// It returns negative value if no elements are found.
func FindIndex[T any](xs {{ .TypeName }}[T], fn func(T) bool) int {
	return iterator.FindIndex[T](xs.Iter(), fn)
}

// FindElem returns a first element in xs that equals to e in the sense of given Eq.
// It returns false as a second return value if no elements are found.
func FindElem[T any](xs {{ .TypeName }}[T], e T, eq cmp.Eq[T]) (T, bool) {
	return iterator.FindElem[T](xs.Iter(), e, eq)
}

// FindElemIndex returns a first index of an element in xs that equals to e in the sense of given Eq.
// It returns negative value if no elements are found.
func FindElemIndex[T any](xs {{ .TypeName }}[T], e T, eq cmp.Eq[T]) int {
	return iterator.FindElemIndex[T](xs.Iter(), e, eq)
}

// Map(xs, f) returns a collection that applies f to each element of xs.
func Map[T, U any](xs {{ .TypeName }}[T], fn func(T) U) {{ .TypeName }}[U] {
	return FromIterator[U](iterator.Map[T, U](xs.Iter(), fn))
}

// Fold accumulates every element in a collection by applying fn.
func Fold[T, U any](init T, xs {{ .TypeName }}[U], fn func(T, U) T) T {
	return iterator.Fold[T, U](init, xs.Iter(), fn)
}

// Zip combines two collections into one that contains pairs of corresponding elements.
func Zip[T, U any](a {{ .TypeName }}[T], b {{ .TypeName }}[U]) {{ .TypeName }}[pair.Pair[T, U]] {
	return FromIterator[pair.Pair[T, U]](iterator.Zip(a.Iter(), b.Iter()))
}

// SumWithInit sums up init and all values in xs.
func SumWithInit[T any](init T, xs {{ .TypeName }}[T], s algebra.Semigroup[T]) T {
	return Fold[T, T](init, xs, s.Combine)
}

// Sum sums up all values in xs.
// It returns m.Empty() when xs is empty.
func Sum[T any](xs {{ .TypeName }}[T], m algebra.Monoid[T]) T {
	var s algebra.Semigroup[T] = m
	return SumWithInit[T](m.Empty(), xs, s)
}
`
